import{_ as n,c as s,o as a,d as e}from"./app.ba9181fa.js";const h='{"title":"Jasper as Mediator","description":"","frontmatter":{},"headers":[{"level":2,"title":"Getting a Response","slug":"getting-a-response"}],"relativePath":"guide/mediator.md","lastUpdated":1655944673972}',t={},o=e(`<h1 id="jasper-as-mediator" tabindex="-1">Jasper as Mediator <a class="header-anchor" href="#jasper-as-mediator" aria-hidden="true">#</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>All of the code on this page is from <a href="https://github.com/JasperFx/jasper/tree/master/src/Samples/InMemoryMediator" target="_blank" rel="noopener noreferrer">the InMemoryMediator sample project</a>.</p></div><p>Recently there&#39;s been some renewed interest in the old <a href="https://en.wikipedia.org/wiki/Mediator_pattern" target="_blank" rel="noopener noreferrer">Gof Mediator pattern</a> as a way to isolate the actual functionality of web services and applications from the mechanics of HTTP request handling. In more concrete terms for .Net developers, a mediator tool allows you to keep MVC Core code ceremony out of your application business logic and service layer. It wasn&#39;t the original motivation of the project, but Jasper can be used as a full-featured mediator tool.</p><p>Let&#39;s jump into a sample project. Let&#39;s say that your system creates and tracks <em>Items</em> of some sort. One of the API requirements is to expose an HTTP endpoint that can accept an input that will create and persist a new <code>Item</code>, while also publishing an <code>ItemCreated</code> event message to any other system (or internal listener within the same system). For the technology stack, let&#39;s use:</p><ul><li><a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-6.0" target="_blank" rel="noopener noreferrer">MVC Core</a> as the Web API framework, but I&#39;m mostly using the newer Minimal API feature for this</li><li>Jasper as our mediator of course!</li><li>Sql Server as the backing database store, using <a href="/guide/persistence/sqlserver.html">Jasper&#39;s Sql Server message persistence</a></li><li><a href="https://docs.microsoft.com/en-us/ef/core/" target="_blank" rel="noopener noreferrer">EF Core</a> as the persistence mechanism</li></ul><p>First off, let&#39;s start a new project with the <code>dotnet new webapi</code> template. Next, we&#39;ll add some configuration to add in Jasper, a small EF Core <code>ItemDbContext</code> service, and wire up our new service for Jasper&#39;s outbox and EF Core middleware:</p><p>From there, we&#39;ll slightly modify the <code>Program</code> file generated by the <code>webapi</code> template to add Jasper and opt into Jasper&#39;s <a href="/guide/command-line.html">extended command line support</a>:</p><p><a id="snippet-sample_inmediatorprogram"></a></p><div class="language-cs"><pre><code><span class="token class-name"><span class="token keyword">var</span></span> builder <span class="token operator">=</span> WebApplication<span class="token punctuation">.</span><span class="token function">CreateBuilder</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name"><span class="token keyword">var</span></span> connectionString <span class="token operator">=</span> builder<span class="token punctuation">.</span>Configuration<span class="token punctuation">.</span><span class="token function">GetConnectionString</span><span class="token punctuation">(</span><span class="token string">&quot;SqlServer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

builder<span class="token punctuation">.</span>Host<span class="token punctuation">.</span><span class="token function">UseJasper</span><span class="token punctuation">(</span>opts <span class="token operator">=&gt;</span>
<span class="token punctuation">{</span>
    <span class="token comment">// TODO -- use single helper that can read the connection string</span>
    <span class="token comment">// from the DbContext</span>
    opts<span class="token punctuation">.</span><span class="token function">PersistMessagesWithSqlServer</span><span class="token punctuation">(</span>connectionString<span class="token punctuation">)</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span><span class="token function">UseEntityFrameworkCorePersistence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Register the EF Core DbContext</span>
builder<span class="token punctuation">.</span>Services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddDbContext</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>ItemsDbContext<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>
    x <span class="token operator">=&gt;</span> x<span class="token punctuation">.</span><span class="token function">UseSqlServer</span><span class="token punctuation">(</span>connectionString<span class="token punctuation">)</span><span class="token punctuation">,</span>

    <span class="token comment">// This is important! Using Singleton scoping</span>
    <span class="token comment">// of the options allows Jasper + Lamar to significantly</span>
    <span class="token comment">// optimize the runtime pipeline of the handlers that</span>
    <span class="token comment">// use this DbContext type</span>
    optionsLifetime<span class="token punctuation">:</span> ServiceLifetime<span class="token punctuation">.</span>Singleton<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><sup><a href="https://github.com/JasperFx/alba/blob/master/src/Samples/InMemoryMediator/Program.cs#L7-L31" title="Snippet source file">snippet source</a> | <a href="#snippet-sample_inmediatorprogram" title="Start of snippet">anchor</a></sup></p><p>Now, let&#39;s add a Jasper message handler that will:</p><ol><li>Handle a new <code>CreateItemCommand</code> message</li><li>Create a new <code>Item</code> entity and persist that with a new <code>ItemsDbContext</code> custom EF Core <code>DbContext</code></li><li>Create and publish a new <code>ItemCreated</code> event message reflecting the new <code>Item</code></li></ol><p>Using idiomatic Jasper, that handler looks like this:</p><p><a id="snippet-sample_inmemorymediator_items"></a></p><div class="language-cs"><pre><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ItemHandler</span>
<span class="token punctuation">{</span>
    <span class="token comment">// This attribute applies Jasper&#39;s EF Core transactional</span>
    <span class="token comment">// middleware</span>
    <span class="token punctuation">[</span>Transactional<span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name">ItemCreated</span> <span class="token function">Handle</span><span class="token punctuation">(</span>
        <span class="token comment">// This would be the message</span>
        <span class="token class-name">CreateItemCommand</span> command<span class="token punctuation">,</span>

        <span class="token comment">// Any other arguments are assumed</span>
        <span class="token comment">// to be service dependencies</span>
        <span class="token class-name">ItemsDbContext</span> db<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Create a new Item entity</span>
        <span class="token class-name"><span class="token keyword">var</span></span> item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Item</span>
        <span class="token punctuation">{</span>
            Name <span class="token operator">=</span> command<span class="token punctuation">.</span>Name
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// Add the item to the current</span>
        <span class="token comment">// DbContext unit of work</span>
        db<span class="token punctuation">.</span>Items<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// This event being returned</span>
        <span class="token comment">// by the handler will be automatically sent</span>
        <span class="token comment">// out as a &quot;cascading&quot; message</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ItemCreated</span>
        <span class="token punctuation">{</span>
            Id <span class="token operator">=</span> item<span class="token punctuation">.</span>Id
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><sup><a href="https://github.com/JasperFx/alba/blob/master/src/Samples/InMemoryMediator/ItemHandler.cs#L5-L40" title="Snippet source file">snippet source</a> | <a href="#snippet-sample_inmemorymediator_items" title="Start of snippet">anchor</a></sup></p><p><strong>Note</strong>, as long as this handler class is public and in the main application assembly, Jasper is going to find it and wire it up inside its execution pipeline. There&#39;s no explicit code or funky IoC registration necessary.</p><p>Now, moving up to the API layer, we can add a new HTTP endpoint to delegate to Jasper as a mediator with:</p><p><a id="snippet-sample_inmemorymediator_usejasperasmediatorcontroller"></a></p><div class="language-cs"><pre><code>app<span class="token punctuation">.</span><span class="token function">MapPost</span><span class="token punctuation">(</span><span class="token string">&quot;/items/create&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">CreateItemCommand</span> cmd<span class="token punctuation">,</span> <span class="token class-name">ICommandBus</span> bus<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bus<span class="token punctuation">.</span><span class="token function">InvokeAsync</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><sup><a href="https://github.com/JasperFx/alba/blob/master/src/Samples/InMemoryMediator/Program.cs#L46-L50" title="Snippet source file">snippet source</a> | <a href="#snippet-sample_inmemorymediator_usejasperasmediatorcontroller" title="Start of snippet">anchor</a></sup></p><p>There isn&#39;t much to this code -- and that&#39;s the entire point! When Jasper registers itself into a .Net Core application, it adds the <code>ICommandBus</code> service to the underlying system IoC container so it can be injected into controller classes or Minimal API endpoint as shown above.The <code>ICommandBus.InvokeAsync(message)</code> method takes the message passed in, finds the correct execution path for the message type, and executes the correct Jasper handler(s) as well as any of the registered <a href="/guide/messages/middleware.html">Jasper middleware</a>.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>This execution happens inline, but will use the <em>RetryNow</em> error handling capabilities. See <a href="/guide/messages/error-handling.html">Jasper&#39;s error handling</a> for more information.</p></div><p>See also:</p><ul><li><a href="/guide/messages/handlers.html#cascading-messages-from-actions">Cascading messages from actions</a> for a better explanation of how the <code>ItemCreated</code> event message is automatically published if the handler success.</li><li><a href="/guide/messages/">Messages and message handlers</a> for the details of how to write Jasper message handlers and how they are discovered</li></ul><p>As a contrast, here&#39;s what the same functionality looks like if you write all the functionality out explicitly in a controller action:</p><p><a id="snippet-sample_inmemorymediator_doitallmyselfitemcontroller"></a></p><div class="language-cs"><pre><code><span class="token comment">// This controller does all the transactional work and business</span>
<span class="token comment">// logic all by itself</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoItAllMyselfItemController</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">ControllerBase</span></span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">IExecutionContext</span> _messaging<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> <span class="token class-name">ItemsDbContext</span> _db<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">DoItAllMyselfItemController</span><span class="token punctuation">(</span><span class="token class-name">IExecutionContext</span> messaging<span class="token punctuation">,</span> <span class="token class-name">ItemsDbContext</span> db<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        _messaging <span class="token operator">=</span> messaging<span class="token punctuation">;</span>
        _db <span class="token operator">=</span> db<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">HttpPost</span><span class="token attribute-arguments"><span class="token punctuation">(</span><span class="token string">&quot;/items/create3&quot;</span><span class="token punctuation">)</span></span></span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Create</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">FromBody</span></span><span class="token punctuation">]</span> <span class="token class-name">CreateItemCommand</span> command<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// Start the &quot;Outbox&quot; transaction</span>
        <span class="token keyword">await</span> _messaging<span class="token punctuation">.</span><span class="token function">EnlistInOutboxAsync</span><span class="token punctuation">(</span>_db<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Create a new Item entity</span>
        <span class="token class-name"><span class="token keyword">var</span></span> item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Item</span>
        <span class="token punctuation">{</span>
            Name <span class="token operator">=</span> command<span class="token punctuation">.</span>Name
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// Add the item to the current</span>
        <span class="token comment">// DbContext unit of work</span>
        _db<span class="token punctuation">.</span>Items<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Publish an event to anyone</span>
        <span class="token comment">// who cares that a new Item has</span>
        <span class="token comment">// been created</span>
        <span class="token class-name"><span class="token keyword">var</span></span> @<span class="token keyword">event</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ItemCreated</span>
        <span class="token punctuation">{</span>
            Id <span class="token operator">=</span> item<span class="token punctuation">.</span>Id
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        <span class="token comment">// Because the message context is enlisted in an</span>
        <span class="token comment">// &quot;outbox&quot; transaction, these outgoing messages are</span>
        <span class="token comment">// held until the ongoing transaction completes</span>
        <span class="token keyword">await</span> _messaging<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span>@<span class="token keyword">event</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Commit the unit of work. This will persist</span>
        <span class="token comment">// both the Item entity we created above, and</span>
        <span class="token comment">// also a Jasper Envelope for the outgoing</span>
        <span class="token comment">// ItemCreated message</span>
        <span class="token keyword">await</span> _db<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// After the DbContext transaction succeeds, kick out</span>
        <span class="token comment">// the persisted messages in the context &quot;outbox&quot;</span>
        <span class="token keyword">await</span> _messaging<span class="token punctuation">.</span><span class="token function">FlushOutgoingMessagesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><sup><a href="https://github.com/JasperFx/alba/blob/master/src/Samples/InMemoryMediator/DoItAllMyselfItemController.cs#L7-L63" title="Snippet source file">snippet source</a> | <a href="#snippet-sample_inmemorymediator_doitallmyselfitemcontroller" title="Start of snippet">anchor</a></sup></p><p>So one, there&#39;s just more going on in the <code>/items/create</code> HTTP endpoint defined above because you&#39;re needing to do a little bit of additional work that Jasper can do for you inside of its execution pipeline (the outbox mechanics, the cascading message getting published, transaction management). Also though, you&#39;re now mixing up MVC controller stuff like the <code>[HttpPost]</code> attribute to control the Url for the endpoint and the service application code that exercises the data and domain model layers.</p><h2 id="getting-a-response" tabindex="-1">Getting a Response <a class="header-anchor" href="#getting-a-response" aria-hidden="true">#</a></h2><p>The controller methods above would both return an empty response body and the default <code>200 OK</code> status code. But what if you want to return some kind of response body that gave the client of the web service some kind of contextual information about the newly created <code>Item</code>.</p><p>To that end, let&#39;s write a different controller action that will relay the body of the <code>ItemCreated</code> output of the message handler to the HTTP response body (and assume we&#39;ll use JSON because that makes the example code simpler):</p><p><a id="snippet-sample_inmemorymediator_withresponsecontroller"></a></p><div class="language-cs"><pre><code>app<span class="token punctuation">.</span><span class="token function">MapPost</span><span class="token punctuation">(</span><span class="token string">&quot;/items/create2&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">CreateItemCommand</span> cmd<span class="token punctuation">,</span> <span class="token class-name">ICommandBus</span> bus<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> bus<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">InvokeAsync</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>ItemCreated<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><sup><a href="https://github.com/JasperFx/alba/blob/master/src/Samples/InMemoryMediator/Program.cs#L52-L56" title="Snippet source file">snippet source</a> | <a href="#snippet-sample_inmemorymediator_withresponsecontroller" title="Start of snippet">anchor</a></sup></p><p>Using the <code>ICommandBus.Invoke&lt;T&gt;(message)</code> overload, the returned <code>ItemCreated</code> response of the message handler is returned from the <code>Invoke()</code> message. To be perfectly clear, this only works if the message handler method returns a cascading message of the exact same type of the designated <code>T</code> parameter.</p>`,37),p=[o];function c(i,l,r,u,m,d){return a(),s("div",null,p)}var g=n(t,[["render",c]]);export{h as __pageData,g as default};
